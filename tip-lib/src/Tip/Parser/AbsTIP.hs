-- Haskell data types for the abstract syntax.
-- Generated by the BNF converter.

{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Tip.Parser.AbsTIP where

import Prelude (Char, Double, Int, Integer, String)
import qualified Prelude as C (Eq, Ord, Show, Read)
import qualified Data.String

newtype UnquotedSymbol = UnquotedSymbol ((Int, Int), String)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

newtype QuotedSymbol = QuotedSymbol ((Int, Int), String)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

newtype Keyword = Keyword String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

data Start = Start [Decl]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Decl
    = DeclareDatatype AttrSymbol Datatype
    | DeclareDatatypes [DatatypeName] [Datatype]
    | DeclareSort AttrSymbol Integer
    | DeclareConst AttrSymbol ConstType
    | DeclareFun AttrSymbol FunType
    | DefineFun FunDec Expr
    | DefineFunRec FunDec Expr
    | DefineFunsRec [BracketedFunDec] [Expr]
    | Formula Assertion [Attr] Expr
    | FormulaPar Assertion [Attr] Par Expr
    | SetLogic Symbol
    | CheckSat
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Assertion = Assert | Prove
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Par = Par [Symbol]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ConstType = ConstTypeMono Type | ConstTypePoly Par Type
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data InnerFunType = InnerFunType [Type] Type
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data FunType
    = FunTypeMono InnerFunType | FunTypePoly Par InnerFunType
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data InnerFunDec = InnerFunDec [Binding] Type
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data FunDec
    = FunDecMono AttrSymbol InnerFunDec
    | FunDecPoly AttrSymbol Par InnerFunDec
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data BracketedFunDec = BracketedFunDec FunDec
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data DatatypeName = DatatypeName AttrSymbol Integer
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data InnerDatatype = InnerDatatype [Constructor]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Datatype
    = DatatypeMono InnerDatatype | DatatypePoly Par InnerDatatype
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Constructor = Constructor AttrSymbol [Binding]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Binding = Binding Symbol Type
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data LetDecl = LetDecl Symbol Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Type
    = TyVar Symbol
    | TyApp Symbol [Type]
    | ArrowTy [Type]
    | IntTy
    | RealTy
    | BoolTy
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Expr
    = Var PolySymbol
    | App Head [Expr]
    | Match Expr [Case]
    | Let [LetDecl] Expr
    | Binder Binder [Binding] Expr
    | Lit Lit
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Lit = LitInt Integer | LitNegInt Integer | LitTrue | LitFalse
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Binder = Lambda | Forall | Exists
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Case = Case Pattern Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Pattern
    = Default | ConPat Symbol [Symbol] | SimplePat Symbol | LitPat Lit
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Head
    = Const PolySymbol
    | At
    | IfThenElse
    | And
    | Or
    | Not
    | Implies
    | Equal
    | Distinct
    | NumAdd
    | NumSub
    | NumMul
    | NumDiv
    | IntDiv
    | IntMod
    | NumGt
    | NumGe
    | NumLt
    | NumLe
    | NumWiden
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data PolySymbol = NoAs Symbol | As Symbol [Type]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data AttrSymbol = AttrSymbol Symbol [Attr]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Attr = NoValue Keyword | Value Keyword Symbol
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Symbol = Unquoted UnquotedSymbol | Quoted QuotedSymbol
  deriving (C.Eq, C.Ord, C.Show, C.Read)

